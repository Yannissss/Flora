#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "l_system.h"
#include "utils.h"

/* 
 * Generate the result string of a given L-System
 * running for n-generations
 */
size_t farm(l_system_t *l_system, char *axiom,
			int generations, char **result)
{
	size_t len = strlen(axiom);
	/* Avoid memory leak freeing *result */
	if ( !*result )
		free(*result);
    /* Init *result at axiom */
    *result = malloc( (len+1)*sizeof(char) );
	strcpy(*result, axiom);
	for (int i = 0;i < generations; ++i)
	{
        /* Calcutate next generation's string length */
        size_t buffer_len = (l_system->f_len-1)*(size_t)occurences(*result, len, 'F')
                          + (l_system->x_len-1)*(size_t)occurences(*result, len, 'X')
                          + len;
        /* Allocate mem. for next generation string without forgetting
         * the space for the null termination character
         */
        char *buffer = malloc( (buffer_len+1)*sizeof(char) );
        int buffer_pos = 0;
        for (int j = 0; j < len; ++j)
        {
            switch ( (*result)[j] )
            {
                case 'F':
                    /* Copying f_rule into new gen. string start at buffer pos */
                    string_insert(l_system->f_rule, l_system->f_len,
                                  buffer+buffer_pos);
                    buffer_pos += l_system->f_len;
                    break;
                case 'X':
                    /* Copying x_rule into new gen. string start at buffer pos */
                    string_insert(l_system->x_rule, l_system->x_len,
                                  buffer+buffer_pos);
                    buffer_pos += l_system->x_len;
                    break;
                default:
                    /* Copying the unchanged character into buffer */
                    buffer[buffer_pos]= (*result)[j];
                    ++buffer_pos;
                    break;
            }
        }
        buffer[buffer_pos] = '\0';
        /* Free old string */
        free(*result);
        /* Set result pointer to new string */
        len = buffer_len;
        *result = buffer;
	}
    return len;
}

/*
 * Generate a point array interpreting the
 * given sequence prev. generated by farm
 * in a 2-D coordinates system
 */
size_t std_compile2f(l_system_t *l_system, char *sequence,
            size_t len, point2f_t **point_arr)
{
    /* Calculate point array size */
    size_t point_number = (size_t)occurences(sequence, len, 'F');
    /* Init pos' stack at start_pos */
    pos2f_stack_t *stack = malloc( sizeof(pos2f_stack_t) );
    stack->top = l_system->start_pos;
    stack->stack = NULL;
    /* Avoid memory leaking by free *point_arr if not empty */
    if ( !(*point_arr) )
        free(*point_arr);
    /* Allocate memory for the point array */
    int point_pos = 0;
    (*point_arr) = malloc( point_number*sizeof(point2f_t) );
    /* Looping throught sequence */
    char *c = NULL;
    for (c = sequence; c < sequence+len; ++c)
    {
        pos2f_t pos = stack->top;
        switch (*c)
        {
            case 'F':
                update2f_top(
                    pos.x + l_system->depth*cos(pos.angle),
                    pos.y + l_system->depth*sin(pos.angle),
                    pos.angle, stack);
                point2f_t point = { pos.x, pos.y };
                (*point_arr)[point_pos] = point;
                ++point_pos;
                break;
            case '+':
                update2f_top(pos.x, pos.y,
                    pos.angle+PI*l_system->angle/180.0, stack);
                break;
            case '-':
                update2f_top(pos.x, pos.y,
                    pos.angle-PI*l_system->angle/180.0, stack);
                break;
            case '[':
                push2f(pos, &stack);
                break;
            case ']':
                pop2f(&stack);
                break;
        }
    }
    /* Free memory used by stack */
    free2f_stack(stack);
    return point_number;
}
